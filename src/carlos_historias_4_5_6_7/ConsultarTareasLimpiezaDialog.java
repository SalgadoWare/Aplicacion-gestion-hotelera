/* 
* To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package carlos_historias_4_5_6_7;

import java.text.SimpleDateFormat;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeSelectionModel;
import jdbc.BD;

/**
 *
 * @author carlos
 */
public class ConsultarTareasLimpiezaDialog extends javax.swing.JDialog {

    /**
     * Creates new form ConsultarTareasLimpiezaDialog
     */
    private ConsultarTareasLimpiezaDialog(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        arbolTareas = new javax.swing.JTree();
        jLabel1 = new javax.swing.JLabel();
        labelFechaTarea = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        bVolver = new javax.swing.JButton();
        bRealizar = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        taObservaciones = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setResizable(false);

        arbolTareas.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                arbolTareasValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(arbolTareas);

        jLabel1.setText("Fecha Tarea:");

        labelFechaTarea.setText("--/--/----");

        jLabel3.setText("Observaciones:");

        bVolver.setBackground(new java.awt.Color(100, 100, 100));
        bVolver.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        bVolver.setForeground(new java.awt.Color(255, 255, 255));
        bVolver.setText("Volver");
        bVolver.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bVolverActionPerformed(evt);
            }
        });

        bRealizar.setBackground(new java.awt.Color(43, 110, 232));
        bRealizar.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        bRealizar.setForeground(new java.awt.Color(255, 255, 255));
        bRealizar.setText("Realizar");
        bRealizar.setEnabled(false);
        bRealizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bRealizarActionPerformed(evt);
            }
        });

        taObservaciones.setEditable(false);
        taObservaciones.setColumns(20);
        taObservaciones.setRows(5);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(taObservaciones, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(taObservaciones, javax.swing.GroupLayout.DEFAULT_SIZE, 222, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 235, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(70, 70, 70)
                        .addComponent(bVolver)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(labelFechaTarea)
                            .addComponent(jLabel3)
                            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(bRealizar)
                        .addGap(66, 66, 66))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelFechaTarea)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bVolver)
                    .addComponent(bRealizar))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void bVolverActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bVolverActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_bVolverActionPerformed

    private void bRealizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bRealizarActionPerformed
        //Calculamos el numero de la habitacion seleccionada
        DefaultMutableTreeNode nodo_seleccionado = (DefaultMutableTreeNode) arbolTareas.getLastSelectedPathComponent();
        TareaLimpieza tarea = (TareaLimpieza) nodo_seleccionado.getUserObject();
        
        //Sacamos los ids de las tareas que se van a realizar
        List<Integer> listaIdTareas = new LinkedList<>();
        
        System.out.println("\n\nTareas que se van a realizar:");
        //Si el nodo seleccionado no tiene hijos
        if(nodo_seleccionado.isLeaf()){
            System.out.println("IdHabitacion: "+tarea.idHabitacion + " IdTarea: "+tarea.idTarea);
            listaIdTareas.add(tarea.idTarea);//Hay una unica tarea que añadir y esta en ese nodo
        }
        else{
            //Si no, hay que recorrer las tareas de esa habitacion y añadir el id de cada una
            int numTareas = nodo_seleccionado.getChildCount();
            DefaultMutableTreeNode nodoTareaActual = nodo_seleccionado.getNextNode();
            for(int i = 0; i < numTareas; i++){
                TareaLimpieza tareaActual = (TareaLimpieza) nodoTareaActual.getUserObject();
                int idTarea = tareaActual.idTarea;
                listaIdTareas.add(idTarea);
                System.out.println("IdHabitacion: "+tareaActual.idHabitacion + " IdTarea: "+idTarea);
                if(i<numTareas-1)
                    nodoTareaActual = nodoTareaActual.getNextNode();
            }
            
        }
        
        System.out.println("IdHabitacion: "+ tarea.idHabitacion + " NombreUsuario: "+nombreUsuario + " IdTareas: "+listaIdTareas);
        //Tenemos que marcar la tarea/tareas como realizadas por el usuario
        BD.marcarTareasDeLimpiezaComoRealizadasPor(nombreUsuario,listaIdTareas);
        
        //actualizo las habitaciones
        iniciarComponentesMio();
        
    }//GEN-LAST:event_bRealizarActionPerformed

    private void arbolTareasValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_arbolTareasValueChanged
        //Mostramos los datos de la tarea de la habitacion seleccionada

        //Returns the last path element of the selection.
        //This method is useful only when the selection model allows a single selection.
        DefaultMutableTreeNode nodo_seleccionado = (DefaultMutableTreeNode) arbolTareas.getLastSelectedPathComponent();

        if (nodo_seleccionado == null)
            //Nothing is selected.
            return;

        Object nodeInfo = nodo_seleccionado.getUserObject();
        if(nodeInfo instanceof TareaLimpieza){
            TareaLimpieza tarea = (TareaLimpieza) nodeInfo;
            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
            labelFechaTarea.setText(sdf.format(tarea.fechaTarea));
            taObservaciones.setText(tarea.observaciones);
        }
        
        //Si la habitacion seleccionada es la 1º de la lista, habilitamos el botón Realizar
        //Solo se puede realizar la habitacion mas prioritaria (va a ser el primer nodo hijo de root)
        
        DefaultMutableTreeNode nodo_primera_habitacion = (DefaultMutableTreeNode) arbolTareas.getModel().getChild(root, 0);
        if(nodo_seleccionado.equals(nodo_primera_habitacion))
            bRealizar.setEnabled(true);
        else
            bRealizar.setEnabled(false);
    }//GEN-LAST:event_arbolTareasValueChanged

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ConsultarTareasLimpiezaDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ConsultarTareasLimpiezaDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ConsultarTareasLimpiezaDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ConsultarTareasLimpiezaDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                ConsultarTareasLimpiezaDialog dialog = new ConsultarTareasLimpiezaDialog(new javax.swing.JFrame(), true);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }
    
    // Codigo mio
    private boolean POK;//Variable ¿pulsó OK?
    
    public ConsultarTareasLimpiezaDialog(){
        this(null,true);//Ventana modal
    }
    
    public boolean showDialog(String nombreUsuario, java.sql.Date fechaActual){
        this.nombreUsuario=nombreUsuario;
        this.fechaActual=fechaActual;
        System.out.println("\nConsultarTareasLimpiezaDialog   nombreUsuario: " + this.nombreUsuario);
        System.out.println("ConsultarTareasLimpiezaDialog   fechaActual: " + this.fechaActual);
        
        // Inicialización de la interfaz
        iniciarComponentesMio();
        
        POK=false;
        setVisible(true);//Mostramos la ventana
        //Es un codigo bloqueante
        //Como la ventana es modal se queda bloqueando la ventana anterior
        //La ventana antigua queda bloqueada porque el metodo setVisible no termina
        return POK;//Aqui POK vale true si el usuario pulso el boton OK y false si pulso Cancelar o cerro la ventana
    }
    
    private void iniciarComponentesMio(){
        taObservaciones.setText("");
        labelFechaTarea.setText("--/--/----");
        bRealizar.setEnabled(false);
        inicializarArbol();
    }
    
    private void inicializarArbol(){
        modificarEstiloArbol();
        añadirTareas();
    }
    
    private void modificarEstiloArbol(){
        arbolTareas.setCellRenderer( new MyTreeCellRenderer());
        arbolTareas.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
    }
    
    private void añadirTareas(){
        root = new DefaultMutableTreeNode("root");
        createNodes(root);
        DefaultTreeModel treeModel = new DefaultTreeModel(root);
        arbolTareas.setModel(treeModel);
        arbolTareas.setRootVisible(false);
    }
    
    private void createNodes(DefaultMutableTreeNode top){
        //Añadimos las tareas
        List<TareaLimpieza> listaTareas = BD.dameTareasLimpiezaDelDiaActualOrdenadasPorFechaYPrioridad(fechaActual);
        
        //Si hay varios tareas correspondientes a la misma habitación tenemos
        //que crear un nuevo nodo Habitacion xxx que tendrá dentro todas las tareas ordenadas

        //Creamos un diccionario de pares (idHabitacion, listaTareas)
        //Hay que usar un LinkedHashMap en lugar de un HashMap normal porque con el Linked se nos guardan los pares
        //en el mismo orden que los metemos, al contrario que con el normal
        LinkedHashMap<String, List<TareaLimpieza>> dicc_habitacion_listaTareas = new LinkedHashMap<>();
        
        for (TareaLimpieza tarea : listaTareas) {
            String numHabitacion = tarea.idHabitacion;
            //Obtenemos la lista de tareas de esa habitacion que esta guardada en el diccionario
            List<TareaLimpieza> listaTareasHabitacionActual = dicc_habitacion_listaTareas.get(numHabitacion);
            //Si no habia una lista de tareas nos devuelve null y tenemos que crearla
            if(listaTareasHabitacionActual==null)
                listaTareasHabitacionActual=new LinkedList<>();
            
            //Añadimos la tarea actual a la lista
            listaTareasHabitacionActual.add(tarea);
            //Metemos en el diccionario la lista de tareas (hace falta por culpa de que la primera vez no hay lista de Tareas) de esa habitacion
            dicc_habitacion_listaTareas.put(numHabitacion,listaTareasHabitacionActual);
        }
        
        //Recorremos el diccionario y para las habitaciones que tengan mas de una tarea (su tamaño de lista será mayor de 1)
        //creamos un nodo Habitacion xxx que será hijo directo de top
        
        for (Map.Entry<String, List<TareaLimpieza>> par : dicc_habitacion_listaTareas.entrySet()) {
            String numHabitacion = par.getKey();
            List<TareaLimpieza> listaTareasHabitacionActual = par.getValue();
            int numTareasHabitacionActual = listaTareasHabitacionActual.size();
            
            System.out.println("NumHabitacion=" + numHabitacion + ", NumTareas=" + numTareasHabitacionActual);
            System.out.println("NumHabitacion=" + numHabitacion + ", ListaTareas=" + listaTareasHabitacionActual);
            //Si la habitacion actual tiene mas de 1 tarea tenemos que crear un nodo con el nombre de la habitacion
            //y meter todas las tareas como nodos hijos de esa habitacion, ordenadas por prioridad y fecha
            if(numTareasHabitacionActual>1){
                //Primero creamos el nodo Habitacion (tiene la informacion de la tarea mas prioritaria)
                //Como la lista de tareas esta ordenada por fecha y prioridad, la primera tarea de la lista
                //sera la mas prioritaria para esa habitacion, por lo que será la informacion de esta la que hay 
                //que poner en el nodo Habitacion
                TareaLimpieza tareaMasPrioritaria = new TareaLimpieza(listaTareasHabitacionActual.get(0));
                DefaultMutableTreeNode nodo_habitacion = new DefaultMutableTreeNode(tareaMasPrioritaria);
                top.add(nodo_habitacion);
                
                int numeroTarea=1;
                //Luego para cada tarea de esa habitacion la añadimos como hija del nodo habitacion
                for (TareaLimpieza tareaLimpieza : listaTareasHabitacionActual) {
                    //Le añadimos numero a la tarea
                    tareaLimpieza.numeroTarea=numeroTarea;
                    //Creamos un nodo con dicha tarea y lo añadimos como hijo de la habitacion actual
                    DefaultMutableTreeNode nodo_tarea = new DefaultMutableTreeNode(tareaLimpieza);
                    nodo_habitacion.add(nodo_tarea);
                    
                    numeroTarea++;
                }
            }else{//Si el numero de tareas es 1
                //Creamos un nodo Habitacion
                DefaultMutableTreeNode nodo_habitacion = new DefaultMutableTreeNode(listaTareasHabitacionActual.get(0));
                top.add(nodo_habitacion);
            }
            
        }          

    }
    
    private DefaultMutableTreeNode root;
    private String nombreUsuario;
    private java.sql.Date fechaActual;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree arbolTareas;
    private javax.swing.JButton bRealizar;
    private javax.swing.JButton bVolver;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelFechaTarea;
    private javax.swing.JTextArea taObservaciones;
    // End of variables declaration//GEN-END:variables
}
